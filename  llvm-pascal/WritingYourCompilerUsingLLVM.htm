<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

  
    <title>  Writing Your Own Toy Compiler Using Flex, Bison and LLVM 
(gnuu.org)</title>
    <meta equiv="X-UA-Compatible" content="chrome=1">
    <meta name="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Keywords" content="loren segal, blog, blogging, youtube,
 videos, web, programming, ruby, python, languages, software, computing,
 computers, nerd, web, internet">
    <meta name="Description" content="I'm Loren Segal, a programmer, 
Rubyist, author of YARD, musician, photographer and writer from 
Montreal, Canada. This is my blog.">
    <meta name="blogcatalog" content="9BC8940314">
    <meta name="Author" content="Loren Segal">
    <link rel="address bar icon" href="http://gnuu.org/favicon.ico">
    <link rel="pingback" href="http://gnuu.org/xmlrpc.php">
    <link rel="alternate" type="application/rss+xml" 
href="http://feeds.feedburner.com/connectnothing">
    <script type="text/javascript" src="WritingYourCompilerUsingLLVM_arquivos/jquery.js"></script>
    <script type="text/javascript" src="WritingYourCompilerUsingLLVM_arquivos/twitter.js"></script>
    <script type="text/javascript" src="WritingYourCompilerUsingLLVM_arquivos/highlight.js"></script>
    <script type="text/javascript">
      $(function() {
                $('#content pre').each(function() { $(this).html('<code class="' + this.className.replace(/^sh_/, '') + '">' + $(this).html() + '</code>'); });
        hljs.initHighlighting();
      });
      
    </script>
    <link rel="stylesheet" 
href="WritingYourCompilerUsingLLVM_arquivos/style.css" type="text/css" 
media="screen">
    	<link rel="archives" title="March 2010" 
href="http://gnuu.org/2010/03/">
	<link rel="archives" title="December 2009" 
href="http://gnuu.org/2009/12/">
	<link rel="archives" title="November 2009" 
href="http://gnuu.org/2009/11/">
	<link rel="archives" title="October 2009" 
href="http://gnuu.org/2009/10/">
	<link rel="archives" title="September 2009" 
href="http://gnuu.org/2009/09/">
	<link rel="archives" title="August 2009" 
href="http://gnuu.org/2009/08/">
	<link rel="archives" title="July 2009" href="http://gnuu.org/2009/07/">
	<link rel="archives" title="June 2009" href="http://gnuu.org/2009/06/">
	<link rel="archives" title="May 2009" href="http://gnuu.org/2009/05/">
	<link rel="archives" title="March 2009" href="http://gnuu.org/2009/03/">
	<link rel="archives" title="February 2009" 
href="http://gnuu.org/2009/02/">
	<link rel="archives" title="January 2009" 
href="http://gnuu.org/2009/01/">
	<link rel="archives" title="October 2008" 
href="http://gnuu.org/2008/10/">
	<link rel="archives" title="September 2008" 
href="http://gnuu.org/2008/09/">
	<link rel="archives" title="August 2008" 
href="http://gnuu.org/2008/08/">
	<link rel="archives" title="July 2008" href="http://gnuu.org/2008/07/">
	<link rel="archives" title="May 2008" href="http://gnuu.org/2008/05/">
	<link rel="archives" title="April 2008" href="http://gnuu.org/2008/04/">
	<link rel="archives" title="March 2008" href="http://gnuu.org/2008/03/">
	<link rel="archives" title="February 2008" 
href="http://gnuu.org/2008/02/">
	<link rel="archives" title="January 2008" 
href="http://gnuu.org/2008/01/">
        <link rel="alternate" type="application/rss+xml" title="gnuu.org
 » Writing Your Own Toy Compiler Using Flex, Bison and LLVM Comments 
Feed" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/feed/">
<link rel="EditURI" type="application/rsd+xml" title="RSD" 
href="http://gnuu.org/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" 
href="http://gnuu.org/wp-includes/wlwmanifest.xml"> 
<link rel="index" title="gnuu.org" href="http://gnuu.org/">
<link rel="start" title="CUSEC Getting Some Great Press" 
href="http://gnuu.org/2008/01/20/cusec-getting-some-great-press/">
<link rel="prev" title="The Angel" 
href="http://gnuu.org/2009/09/17/the-angel/">
<link rel="next" title="The Joy of Solving Problems, All of Them" 
href="http://gnuu.org/2009/10/01/the-joy-of-solving-problems-all-of-them/">
<meta name="generator" content="WordPress 2.9.2">
<link rel="canonical" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/">
<link rel="shortlink" href="http://wp.me/pkEpr-4i">  <script src="WritingYourCompilerUsingLLVM_arquivos/in.php" async="" type="text/javascript"></script></head><body>
    <div id="wrapper">
      <div id="content">
        <a id="title" href="http://gnuu.org/"></a>        

  
    <div class="post" id="post-266">
      <h1 class="storytitle">Writing Your Own Toy Compiler Using Flex, 
Bison and LLVM</h1>
            <div class="meta">
        <p>By Loren Segal on September 18th, 2009 at 1:08 PM </p>
      </div>
      
      <div class="storycontent">
        <p style="text-align: left;"></p><form name="content_jump"><select
 class="contentjumpddl" onchange="location = 
this.options[this.selectedIndex].value;"><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/">1. 
Introduction</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/2/">2. 
Getting Started</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/3/">3. 
Step1. Lexical Analysis with Flex</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/4/">4. 
Step 2. Semantic Parsing with Bison</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/5/">5. 
Generating Flex and Bison Code</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/6/">6. 
Step 3. Assembling the AST with LLVM</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/7/">7. 
Building and Running Our Toy Language</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/8/">8. 
Conclusion</option><option 
value="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/all/1" 
selected="selected">9. View All</option></select></form><p><!--pagetitle:Introduction--></p>
<p class="note"><strong>Update (March 19 2010)</strong>: this article 
was updated for <strong>LLVM 2.6</strong> thanks to a great patch by <a 
href="http://github.com/ashgti/my_toy_compiler">John Harrison</a>. He 
rocks!</p>
<p>I’ve always been interested in compilers and languages, but interest 
only gets you so far. A lot of the concepts of compiler design can 
easily go way over most programmers’ heads, even the intelligent ones. 
Needless to say, I’ve tried, without much success, to write a small toy 
language/compiler before. I’d usually get caught up at the semantic 
parsing stage. And again, needless to say, this post is mostly inspired 
by my latest attempt, though this one has been much more successful (so 
far).</p>
<p>Fortunately over the last few years I’ve been involved in <a 
href="http://yard.soen.ca/">some</a> <a 
href="http://www.eecs.ucf.edu/%7Eleavens/JML//index.shtml">projects</a> 
that helped give me perspective and experience on what’s really involved
 in building a compiler. The other thing I’ve been lucky to have in my 
corner this time is the help of <a href="http://llvm.org/">LLVM</a>, a 
tool which I’m hardly qualified to talk too much about, but it’s been 
quite handy in implementing most of the business end (read: complex 
aspects) of my toy compiler.</p>
<p> <!-- more --><br>
</p><h2>So Why Are You Reading This? </h2>
<p>Maybe you want to see what I’ve been doing with my time. It’s more 
likely, however, that you’re probably interested in compilers and 
languages as I am, and have probably been hitting similar roadblocks. 
You’ve probably wanted to try this but never found the resources, or did
 but couldn’t quite follow. The goal of this article is to provide such a
 resource and explain in a relatively step by step manner how to create 
the most basic-but-functional compiler from start to “finish”. </p>
<p>I won’t be covering much theory, so if you haven’t brushed up on your
 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF 
grammars</a>, <a 
href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST data 
structures</a> and the basic <a 
href="http://en.wikipedia.org/wiki/Compiler">compiler pipeline</a>, I 
suggest you do so. That said, I plan on keeping this as simple as 
possible. The goal, of course, is to make this an easy-to-understand 
introductory resource for people interested but not experienced with 
compilers. </p>
<h2></h2>
<h2>What You Will End Up With</h2>
<p>If you follow this article, you should end up with a language that 
can define functions, call functions, define variables, assign data to 
variables and perform basic math operations. It will support two basic 
types, doubles and integers. Some of the functionality is unimplemented,
 so you can have the satisfaction of actually implementing some of this 
stuff yourself and get the hang of writing a compiler with a little 
help.</p>
<h2>Let’s Get Some Questions Out of the Way</h2>
<h3>1. What languages do I need to know?</h3>
<p>The tools we’ll be using are C/C++ based. LLVM is specifically C++ 
and our toy language will follow suit since there are some niceties of 
OOP and the STL (C++’s stdlib) that make for fewer lines of code. In 
addition to C, both Lex and Bison have their own syntax which may seem 
daunting at first, but I’ll try to explain as much as possible. The 
grammar we’re dealing with is actually very tiny (~100 LOC), so it 
should be feasible.</p>
<h3>2. Is this really complicated? </h3>
<p>Yes and no. There is plenty of stuff going on here and it might seem 
scary at first, but honestly, this is about as simple as it gets. We 
will also use a lot of tools to abstract the layers of complexity and 
make it manageable.</p>
<h3>3. How long will it take?</h3>
<p>What we will be building took me about 3 days of toying with, but I 
have a few failed attempts under my belt and those do have impact on my 
comprehension. Of course, this will be a “follow me” kind of deal, so it
 should be much shorter for you. To understand completely everything 
might take a little longer, but you should be able to run through all of
 this stuff (and hopefully understand a good amount of it) in an 
afternoon.</p>
<p>So, if you’re ready, let’s get started.</p>
<p><!--nextpage--><br>
<!--pagetitle:Getting Started--></p>
<h2>The Basic Compiler Recipe</h2>
<p>Although you should already pretty much know this, a compiler is 
really a grouping of three to four components (there are some more 
sub-components) where data is fed from one to the next in a pipeline 
fashion. We will be using a different tool to help us build out each of 
these components. Here is a diagram of each step and the tool we will 
use:</p>
<p><img alt="Compiler Pipeline" 
src="WritingYourCompilerUsingLLVM_arquivos/pipeline.png" height="76" 
width="620"> </p>
<p>You’ll notice the linker step is greyed out. Our toy language won’t 
be supporting compile time linking (plus most languages don’t do compile
 time linking anymore anyway). To do our lexing we will be using the 
open source tool Lex, mostly available these days as <a 
href="http://flex.sourceforge.net/">Flex</a>. Lexing usually goes hand 
in hand with semantic parsing, which we’ll be performing with the help 
of Yacc, better known as <a href="http://www.gnu.org/software/bison/">Bison</a>.
 Finally, once semantic parsing is done we can walk over our AST and 
generate our “bytecode”, or machine code. For this, we’ll be using <a 
href="http://llvm.org/">LLVM</a>, which technically generates 
intermediate bytecode, but we will be using LLVM’s JIT (Just In Time) 
compilation to execute this bytecode on our machine. </p>
<p>To summarize, the steps are as follows:</p>
<ol>
<li><strong>Lexical Analysis with <em>Flex</em></strong>: Split input 
data into a set of tokens (identifiers, keywords, numbers, brackets, 
braces, etc.) </li>
<li><strong>Semantic Parsing with <em>Bison</em></strong>: Generate an 
AST while parsing the tokens. Bison will do most of the legwork here, we
 just need to define our AST. </li>
<li><strong>Assembly with <em>LLVM</em></strong>: This is where we walk 
over our AST and generate byte/machine code for each node. As crazy as 
it sounds, this is probably the <em>easiest</em> step. </li>
</ol>
<p>Before moving too far along, you should probably consider installing 
Flex, Bison and LLVM, if you haven’t already. We’re going to need them 
pretty soon.</p>
<h2></h2>
<h2>Defining Our Grammar</h2>
<p>Our grammar is naturally the most central part of our language. From 
our grammar we inherently allow or disallow functionality. For our toy 
compiler, we will be using a standard C-like syntax because it’s 
familiar and simple to parse. The canonical example of our toy language 
will be the following code:</p>
<pre><code class="c ruby"><span class="identifier">int</span> <span class="identifier">do_math</span>(<span class="identifier">int</span> <span class="identifier">a</span>) {
  <span class="identifier">int</span> <span class="identifier">x</span> = <span class="identifier">a</span> * <span class="number">5</span> + <span class="number">3</span>
}

<span class="identifier">do_math</span>(<span class="number">10</span>)</code></pre>
<p>Looks simple enough. We can see it’s typed the same way C is, but 
there are no semicolons separating statements. You’ll also notice there 
is no “return” statement in our grammar; this is something you can 
implement on your own.</p>
<p>There’s also no mechanism to print any results or anything. We will 
verify the correctness of our programs by inspecting the <em>very pretty</em>
 instruction listing that LLVM can print of the bytecode we’ve compiled,
 but more on that later.</p>
<p><!--nextpage--><br>
<!--pagetitle:Step1. Lexical Analysis with Flex--></p>
<h2>Step 1. Lexical Analysis with Flex</h2>
<p>This is the simplest step. Given our grammar, we need to break down 
our input into a list of known tokens. As mentioned before, our grammar 
has very basic tokens: identifiers, numbers (integers and floats), the 
mathematical operators, parentheses and braces. Our lex file “tokens.l”,
 which has a somewhat specialized grammar, is simply defined as:</p>
<p class="note">Listing of tokens.l:</p>
<pre><code class="cpp">%{
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include "node.h"</span>
<span class="preprocessor">#include "parser.hpp"</span>
<span class="preprocessor">#define SAVE_TOKEN yylval.string = new std::string(yytext, yyleng)</span>
<span class="preprocessor">#define TOKEN(t) (yylval.token = t)</span>
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> yywrap() { }
%}

%%

[ \t\n]                 ;
[a-zA-Z_][a-zA-Z0-<span class="number">9</span>_]*  SAVE_TOKEN; <span class="keyword">return</span> TIDENTIFIER;
[<span class="number">0</span>-<span class="number">9</span>]+\.[<span class="number">0</span>-<span class="number">9</span>]*          SAVE_TOKEN; <span class="keyword">return</span> TDOUBLE;
[<span class="number">0</span>-<span class="number">9</span>]+                  SAVE_TOKEN; <span class="keyword">return</span> TINTEGER;
<span class="string">"="</span>                     <span class="keyword">return</span> TOKEN(TEQUAL);
<span class="string">"=="</span>                    <span class="keyword">return</span> TOKEN(TCEQ);
<span class="string">"!="</span>                    <span class="keyword">return</span> TOKEN(TCNE);
<span class="string">"&lt;"</span>                     <span class="keyword">return</span> TOKEN(TCLT);
<span class="string">"&lt;="</span>                    <span class="keyword">return</span> TOKEN(TCLE);
<span class="string">"&gt;"</span>                     <span class="keyword">return</span> TOKEN(TCGT);
<span class="string">"&gt;="</span>                    <span class="keyword">return</span> TOKEN(TCGE);
<span class="string">"("</span>                     <span class="keyword">return</span> TOKEN(TLPAREN);
<span class="string">")"</span>                     <span class="keyword">return</span> TOKEN(TRPAREN);
<span class="string">"{"</span>                     <span class="keyword">return</span> TOKEN(TLBRACE);
<span class="string">"}"</span>                     <span class="keyword">return</span> TOKEN(TRBRACE);
<span class="string">"."</span>                     <span class="keyword">return</span> TOKEN(TDOT);
<span class="string">","</span>                     <span class="keyword">return</span> TOKEN(TCOMMA);
<span class="string">"+"</span>                     <span class="keyword">return</span> TOKEN(TPLUS);
<span class="string">"-"</span>                     <span class="keyword">return</span> TOKEN(TMINUS);
<span class="string">"*"</span>                     <span class="keyword">return</span> TOKEN(TMUL);
<span class="string">"/"</span>                     <span class="keyword">return</span> TOKEN(TDIV);
.                       printf(<span class="string">"Unknown token!\n"</span>); yyterminate();

%%</code></pre>
<p>The first section declares some specialized C code. We use a 
“SAVE_TOKEN” macro to keep the text of identifiers and numbers somewhere
 safe (instead of just the token itself), since Bison won’t have access 
to our ‘yytext’ variable. The first token tells us to skip all 
whitespace. You’ll also notice that we have some equality comparison 
tokens and such. Those are unimplemented for now, feel free to support 
them in your toy compiler!</p>
<p>So all we’re doing here is defining the tokens and their symbolic 
names. These symbols (TIDENTIFIER, etc.) will become “terminal symbols” 
in our grammar. We’re just returning them, but we’ve never defined them.
 <strong>Where are they defined?</strong> Why, in the bison grammar, of 
course. The parser.hpp file we’ve included will be generated by bison, 
and all the tokens inside it will be generated and available for use.</p>
<p>We run Flex on this tokens.l file to generate our “tokens.cpp” file, 
which will be compiled alongside our parser and provide the yylex() 
function that recognizes all of these tokens. We will run this command 
later though, because we need to generate that header file from bison 
first!</p>
<p><!--nextpage--><br>
<!--pagetitle:Step 2. Semantic Parsing with Bison--></p>
<h2>Step 2. Semantic Parsing with Bison</h2>
<p>This is the challenging part of our mission. Generating an accurate, 
unambiguous grammar is not simple and takes a little bit of practice. 
Fortunately, our grammar is both simple and, for your benefit, mostly 
completed. Before we get into implementing our grammar, though, we need 
to talk design for a bit.</p>
<h3>Designing the AST</h3>
<p>The end product of semantic parsing is an AST. As we will see, Bison 
is quite elegantly optimized to generate AST’s; it’s really only a 
matter of plugging our nodes into the grammar. </p>
<p>The same way a string such as “int x” represents our language in text
 form, our AST is what represents our language in memory (before it is 
assembled). As such, we need to build up the data structures we will be 
using before we have the chance of plugging them into our grammar file. 
This process is pretty straightforward because we are basically creating
 a structure for every semantic that can be expressed by our language. 
Method calls, method declarations, variable declarations, references, 
these are all candidates for AST nodes. A complete diagram of the nodes 
in our language is as follows:</p>
<p><img alt="Our Toy Language AST" 
src="WritingYourCompilerUsingLLVM_arquivos/ClassDiagram.png" border="0" 
height="505" width="640"> </p>
<p>The C++ that represents the above specifications is:</p>
<p class="note">Listing of node.h:</p>
<pre><code class="cpp"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;llvm/Value.h&gt;</span>

<span class="keyword">class</span> CodeGenContext;
<span class="keyword">class</span> NStatement;
<span class="keyword">class</span> NExpression;
<span class="keyword">class</span> NVariableDeclaration;

<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;NStatement*&gt;</span> StatementList;
<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;NExpression*&gt;</span> ExpressionList;
<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;NVariableDeclaration*&gt;</span> VariableList;

<span class="keyword">class</span> Node {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> ~Node() {}
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context) { }
};

<span class="keyword">class</span> NExpression : <span class="keyword">public</span> Node {
};

<span class="keyword">class</span> NStatement : <span class="keyword">public</span> Node {
};

<span class="keyword">class</span> NInteger : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    <span class="keyword">long</span> <span class="keyword">long</span> value;
    NInteger(<span class="keyword">long</span> <span class="keyword">long</span> value) : value(value) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NDouble : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    <span class="keyword">double</span> value;
    NDouble(<span class="keyword">double</span> value) : value(value) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NIdentifier : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> name;
    NIdentifier(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : name(name) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NMethodCall : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    <span class="keyword">const</span> NIdentifier&amp; id;
    ExpressionList arguments;
    NMethodCall(<span class="keyword">const</span> NIdentifier&amp; id, ExpressionList&amp; arguments) :
        id(id), arguments(arguments) { }
    NMethodCall(<span class="keyword">const</span> NIdentifier&amp; id) : id(id) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NBinaryOperator : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    <span class="keyword">int</span> op;
    NExpression&amp; lhs;
    NExpression&amp; rhs;
    NBinaryOperator(NExpression&amp; lhs, <span class="keyword">int</span> op, NExpression&amp; rhs) :
        lhs(lhs), rhs(rhs), op(op) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NAssignment : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    NIdentifier&amp; lhs;
    NExpression&amp; rhs;
    NAssignment(NIdentifier&amp; lhs, NExpression&amp; rhs) :
        lhs(lhs), rhs(rhs) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NBlock : <span class="keyword">public</span> NExpression {
<span class="keyword">public</span>:
    StatementList statements;
    NBlock() { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NExpressionStatement : <span class="keyword">public</span> NStatement {
<span class="keyword">public</span>:
    NExpression&amp; expression;
    NExpressionStatement(NExpression&amp; expression) :
        expression(expression) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NVariableDeclaration : <span class="keyword">public</span> NStatement {
<span class="keyword">public</span>:
    <span class="keyword">const</span> NIdentifier&amp; type;
    NIdentifier&amp; id;
    NExpression *assignmentExpr;
    NVariableDeclaration(<span class="keyword">const</span> NIdentifier&amp; type, NIdentifier&amp; id) :
        type(type), id(id) { }
    NVariableDeclaration(<span class="keyword">const</span> NIdentifier&amp; type, NIdentifier&amp; id, NExpression *assignmentExpr) :
        type(type), id(id), assignmentExpr(assignmentExpr) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};

<span class="keyword">class</span> NFunctionDeclaration : <span class="keyword">public</span> NStatement {
<span class="keyword">public</span>:
    <span class="keyword">const</span> NIdentifier&amp; type;
    <span class="keyword">const</span> NIdentifier&amp; id;
    VariableList arguments;
    NBlock&amp; block;
    NFunctionDeclaration(<span class="keyword">const</span> NIdentifier&amp; type, <span class="keyword">const</span> NIdentifier&amp; id,
            <span class="keyword">const</span> VariableList&amp; arguments, NBlock&amp; block) :
        type(type), id(id), arguments(arguments), block(block) { }
    <span class="keyword">virtual</span> llvm::Value* codeGen(CodeGenContext&amp; context);
};</code></pre>
<p>Again, fairly straightforward. We’re not using any getters or setters
 here, just public data members; there’s really no need for data hiding.
 Ignore the codeGen method for now. It will come in handy later, when we
 want to export our AST as LLVM bytecode.</p>
<h3>Back to Bison</h3>
<p>Moo. I mean, whatever Bison say. Here’s a short tangent:</p>
<table border="0" cellpadding="2" cellspacing="0" width="400">
<tbody>
<tr>
<td valign="top" width="200"><img style="border-width: 0px; display: 
inline;" title="Bison1" alt="Bison1" 
src="WritingYourCompilerUsingLLVM_arquivos/image.png" border="0" 
height="113" width="300"></td>
<td valign="top" width="200"><img style="border-width: 0px; display: 
inline;" title="Bison2" alt="Bison2" 
src="WritingYourCompilerUsingLLVM_arquivos/image1.png" border="0" 
height="140" width="280"></td>
</tr>
</tbody>
</table>
<p>Anyway, here comes the most complex part and by the same token, the 
hardest to explain. It’s not technically complicated, but I’d have to 
spend a while discussing the details of Bison’s syntax, so let’s take a 
lot of it for granted right now. Realize this, though: we’ll be 
declaring the makeup of each of our valid statements and expressions 
(the ones representing the nodes we’ve defined above) using terminal and
 non-terminal symbols, basically like a BNF grammar. The syntax is also 
similar:</p>
<pre><code class=" ruby"><span class="identifier">if_stmt</span> <span class="symbol">:</span> <span class="constant">IF</span> <span class="string">'('</span> <span class="identifier">condition</span> <span class="string">')'</span> <span class="identifier">block</span> { <span class="regexp">/* do stuff when this rule is encountered */</span> }
        | <span class="constant">IF</span> <span class="string">'('</span> <span class="identifier">condition</span> <span class="string">')'</span>       { ... }
        ;</code></pre>
<p>The above would define an if statement (<em>if</em> we supported it).
 The real difference is that with each grammar comes a set of actions 
(inside the braces) which are executed after it is recognized. This is 
done recursively over the symbols in leaf-to-root order, where each non 
terminal is eventually merged into one big tree. The “$$” symbol you 
will be seeing represents the current root node of each leaf. 
Furthermore, “$1” represents the leaf for the 1st symbol in the rule. In
 the above example, the “$$” we assigned from our “condition” rule would
 be available as “$3" in our “if_stmt” rule. It might start becoming 
clear how our AST ties into this. We will basically be assigning a node 
to “$$” at each of our rules which will eventually be merged into our 
final AST. If not, don’t worry. The Bison part of our toy language is 
again, the most complex portion of our language. It might take a while 
to sink in. Besides, you haven’t even seen the code yet, so, here it is:</p>
<p class="note">Listing of parser.y:</p>
<pre><code class="cpp">%{
    <span class="preprocessor">#include "node.h"</span>
    NBlock *programBlock; <span class="comment">/* the top level root node of our final AST */</span>

    <span class="keyword">extern</span> <span class="keyword">int</span> yylex();
    <span class="keyword">void</span> yyerror(<span class="keyword">const</span> <span class="keyword">char</span> *s) { printf(<span class="string">"ERROR: %s\n"</span>, s); }
%}

<span class="comment">/* Represents the many different ways we can access our data */</span>
%<span class="keyword">union</span> {
    Node *node;
    NBlock *block;
    NExpression *expr;
    NStatement *stmt;
    NIdentifier *ident;
    NVariableDeclaration *var_decl;
    <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;NVariableDeclaration*&gt;</span> *varvec;
    <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;NExpression*&gt;</span> *exprvec;
    <span class="built_in">std</span>::<span class="built_in">string</span> *<span class="built_in">string</span>;
    <span class="keyword">int</span> token;
}

<span class="comment">/* Define our terminal symbols (tokens). This should
   match our tokens.l lex file. We also define the node type
   they represent.
 */</span>
%token &lt;<span class="built_in">string</span>&gt; TIDENTIFIER TINTEGER TDOUBLE
%token &lt;token&gt; TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL
%token &lt;token&gt; TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT
%token &lt;token&gt; TPLUS TMINUS TMUL TDIV

<span class="comment">/* Define the type of node our nonterminal symbols represent.
   The types refer to the %union declaration above. Ex: when
   we call an ident (defined by union type ident) we are really
   calling an (NIdentifier*). It makes the compiler happy.
 */</span>
%type &lt;ident&gt; ident
%type &lt;expr&gt; numeric expr
%type &lt;varvec&gt; func_decl_args
%type &lt;exprvec&gt; call_args
%type &lt;block&gt; program stmts block
%type &lt;stmt&gt; stmt var_decl func_decl
%type &lt;token&gt; comparison

<span class="comment">/* Operator precedence for mathematical operators */</span>
%left TPLUS TMINUS
%left TMUL TDIV

%start program

%%

program : stmts { programBlock = $<span class="number">1</span>; }
        ;

stmts : stmt { $$ = <span class="keyword">new</span> NBlock(); $$-&gt;statements.push_back($&lt;stmt&gt;<span class="number">1</span>); }
      | stmts stmt { $<span class="number">1</span>-&gt;statements.push_back($&lt;stmt&gt;<span class="number">2</span>); }
      ;

stmt : var_decl | func_decl
     | expr { $$ = <span class="keyword">new</span> NExpressionStatement(*$<span class="number">1</span>); }
     ;

block : TLBRACE stmts TRBRACE { $$ = $<span class="number">2</span>; }
      | TLBRACE TRBRACE { $$ = <span class="keyword">new</span> NBlock(); }
      ;

var_decl : ident ident { $$ = <span class="keyword">new</span> NVariableDeclaration(*$<span class="number">1</span>, *$<span class="number">2</span>); }
         | ident ident TEQUAL expr { $$ = <span class="keyword">new</span> NVariableDeclaration(*$<span class="number">1</span>, *$<span class="number">2</span>, $<span class="number">4</span>); }
         ;

func_decl : ident ident TLPAREN func_decl_args TRPAREN block
            { $$ = <span class="keyword">new</span> NFunctionDeclaration(*$<span class="number">1</span>, *$<span class="number">2</span>, *$<span class="number">4</span>, *$<span class="number">6</span>); <span class="keyword">delete</span> $<span class="number">4</span>; }
          ;

func_decl_args : <span class="comment">/*blank*/</span>  { $$ = <span class="keyword">new</span> VariableList(); }
          | var_decl { $$ = <span class="keyword">new</span> VariableList(); $$-&gt;push_back($&lt;var_decl&gt;<span class="number">1</span>); }
          | func_decl_args TCOMMA var_decl { $<span class="number">1</span>-&gt;push_back($&lt;var_decl&gt;<span class="number">3</span>); }
          ;

ident : TIDENTIFIER { $$ = <span class="keyword">new</span> NIdentifier(*$<span class="number">1</span>); <span class="keyword">delete</span> $<span class="number">1</span>; }
      ;

numeric : TINTEGER { $$ = <span class="keyword">new</span> NInteger(atol($<span class="number">1</span>-&gt;c_str())); <span class="keyword">delete</span> $<span class="number">1</span>; }
        | TDOUBLE { $$ = <span class="keyword">new</span> NDouble(atof($<span class="number">1</span>-&gt;c_str())); <span class="keyword">delete</span> $<span class="number">1</span>; }
        ;

expr : ident TEQUAL expr { $$ = <span class="keyword">new</span> NAssignment(*$&lt;ident&gt;<span class="number">1</span>, *$<span class="number">3</span>); }
     | ident TLPAREN call_args TRPAREN { $$ = <span class="keyword">new</span> NMethodCall(*$<span class="number">1</span>, *$<span class="number">3</span>); <span class="keyword">delete</span> $<span class="number">3</span>; }
     | ident { $&lt;ident&gt;$ = $<span class="number">1</span>; }
     | numeric
     | expr comparison expr { $$ = <span class="keyword">new</span> NBinaryOperator(*$<span class="number">1</span>, $<span class="number">2</span>, *$<span class="number">3</span>); }
     | TLPAREN expr TRPAREN { $$ = $<span class="number">2</span>; }
     ;

call_args : <span class="comment">/*blank*/</span>  { $$ = <span class="keyword">new</span> ExpressionList(); }
          | expr { $$ = <span class="keyword">new</span> ExpressionList(); $$-&gt;push_back($<span class="number">1</span>); }
          | call_args TCOMMA expr  { $<span class="number">1</span>-&gt;push_back($<span class="number">3</span>); }
          ;

comparison : TCEQ | TCNE | TCLT | TCLE | TCGT | TCGE
           | TPLUS | TMINUS | TMUL | TDIV
           ;

%%</code></pre>
<p><!--nextpage--><br>
<!--pagetitle:Generating Flex and Bison Code--></p>
<h3>Generating Our Code</h3>
<p>So we have our “tokens.l” file for Flex and our “parser.y” file for 
Bison. To generate our C++ source files from these definition files we 
need to pass them through the tools. Note that Bison will also be 
creating a “parser.hpp” header file for Flex; it does this because of 
the <code>–d</code> switch, which separates our token declarations from 
the source so we can include and use those tokens elsewhere. The 
following commands should create our parser.cpp, parser.hpp and 
tokens.cpp source files.</p>
<pre><code class=" ruby"><span class="variable">$ </span><span class="identifier">bison</span> -<span class="identifier">d</span> -<span class="identifier">o</span> <span class="identifier">parser</span>.<span class="identifier">cpp</span> <span class="identifier">parser</span>.<span class="identifier">y</span>
<span class="variable">$ </span><span class="identifier">lex</span> -<span class="identifier">o</span> <span class="identifier">tokens</span>.<span class="identifier">cpp</span> <span class="identifier">tokens</span>.<span class="identifier">l</span></code></pre>
<p>If everything went well we should now have 2 out of 3 parts of our 
compiler. If you want to test this, create a short main function in a 
main.cpp file:</p>
<p class="note">Listing of main.cpp:</p>
<pre><code class="c ruby"><span class="comment">#include &lt;iostream&gt;</span>
<span class="comment">#include "node.h"</span>
<span class="identifier">extern</span> <span class="constant">NBlock</span>* <span class="identifier">programBlock</span>;
<span class="identifier">extern</span> <span class="identifier">int</span> <span class="identifier">yyparse</span>();

<span class="identifier">int</span> <span class="identifier">main</span>(<span class="identifier">int</span> <span class="identifier">argc</span>, <span class="identifier">char</span> **<span class="identifier">argv</span>)
{
    <span class="identifier">yyparse</span>();
    <span class="identifier">std</span><span class="symbol">:</span><span class="symbol">:<span class="identifier">cout</span></span> &lt;&lt; <span class="identifier">programBlock</span> &lt;&lt; <span class="identifier">endl</span>;
    <span class="identifier"><span class="keyword">return</span></span> <span class="number">0</span>;
}</code></pre>
<p>You can then compile your source files:</p>
<pre><code class=" ruby"><span class="variable">$ </span><span class="identifier">g</span>++ -<span class="identifier">o</span> <span class="identifier">parser</span> <span class="identifier">parser</span>.<span class="identifier">cpp</span> <span class="identifier">tokens</span>.<span class="identifier">cpp</span> <span class="identifier">main</span>.<span class="identifier">cpp</span></code></pre>
<p class="note">You will need to have installed LLVM by now for the <code>llvm::Value</code>
 reference in "node.h". If you don’t want to go that far just yet, you 
can comment out the codeGen() methods in node.h to test just your 
lexer/parser combo.</p>
<p>If all goes well you should now have a “parser” binary that takes 
source in stdin and prints out a hopefully nonzero address representing 
the root node of our AST in memory. </p>
<p><!--nextpage--><br>
<!--pagetitle:Step 3. Assembling the AST with LLVM--></p>
<h2>Step 3. Assembling the AST with LLVM</h2>
<p>The next step in a compiler is to naturally take this AST and turn it
 into machine code. This means converting each semantic node into the 
equivalent machine instruction. LLVM makes this very easy for us, 
because it abstracts the actual instructions to something that is 
similar to an AST. This means all we’re really doing is translating from
 one AST to another.</p>
<p>You can imagine that this process will involve us walking over our 
AST from our root node, and for each node we emit bytecode. This is 
where the <code>codeGen</code> method that we defined for our nodes 
comes in handy. For example, when we visit an <code>NBlock</code> node 
(semantically representing a collection of statements), we call <code>codeGen</code>
 on each statement in the list. It looks like this:</p>
<pre><code class="cpp">Value* NBlock::codeGen(CodeGenContext&amp; context)
{
    StatementList::const_iterator it;
    Value *last = NULL;
    <span class="keyword">for</span> (it = statements.begin(); it != statements.end(); it++) {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Generating code for "</span> &lt;&lt; <span class="keyword">typeid</span>(**it).name() &lt;&lt; endl;
        last = (**it).codeGen(context);
    }
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating block"</span> &lt;&lt; endl;
    <span class="keyword">return</span> last;
}</code></pre>
<p>We implement this method for all of our nodes, then call it as we go 
down the tree, implicitly walking us through our entire AST. We keep a 
new <code>CodeGenContext</code> class around to tell us where to emit 
our bytecode.</p>
<h3>A Big Caveat About LLVM</h3>
<p>One of the downsides of LLVM is that it’s <em>really</em> hard to 
find useful documentation. Their online tutorial and other such docs are
 wildly out of date, and there’s barely any information for the C++ API 
unless you really dig for it. If you installed LLVM on your own, check 
the ‘docs’ as it has "more" up to date documentation.</p>
<p>I’ve found the best way to learn LLVM is by example. There are some 
quick examples of programmatically generating bytecode in the ‘examples’
 directory of the LLVM archive as well, and there’s also <a 
href="http://llvm.org/demo/">the LLVM live demo site</a> which can emit 
C++ API code for a C program as input. This is a great way to find out 
what instructions something like "int x = 5;" will emit. I used the demo
 tool to implement most of the nodes.</p>
<p>Without further ado, I’ll be listing both the codegen.h and 
codegen.cpp files below.</p>
<p class="note">Listing of codegen.h:</p>
<pre><code class="cpp"><span class="preprocessor">#include &lt;stack&gt;</span>
<span class="preprocessor">#include &lt;llvm/Module.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Function.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Type.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/DerivedTypes.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/LLVMContext.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/PassManager.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Instructions.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/CallingConv.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Bitcode/ReaderWriter.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Analysis/Verifier.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Assembly/PrintModulePass.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Support/IRBuilder.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/ModuleProvider.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Target/TargetSelect.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/ExecutionEngine/GenericValue.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/ExecutionEngine/JIT.h&gt;</span>
<span class="preprocessor">#include &lt;llvm/Support/raw_ostream.h&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> llvm;

<span class="keyword">class</span> NBlock;

<span class="keyword">class</span> CodeGenBlock {
<span class="keyword">public</span>:
    BasicBlock *block;
    <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value*&gt;</span> locals;
};

<span class="keyword">class</span> CodeGenContext {
    <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">stack</span>&lt;CodeGenBlock *&gt;</span> blocks;
    Function *mainFunction;

<span class="keyword">public</span>:
    Module *module;
    CodeGenContext() { module = <span class="keyword">new</span> Module(<span class="string">"main"</span>, getGlobalContext()); }

    <span class="keyword">void</span> generateCode(NBlock&amp; root);
    GenericValue runCode();
    <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value*&gt;</span>&amp; locals() { <span class="keyword">return</span> blocks.top()-&gt;locals; }
    BasicBlock *currentBlock() { <span class="keyword">return</span> blocks.top()-&gt;block; }
    <span class="keyword">void</span> pushBlock(BasicBlock *block) { blocks.push(<span class="keyword">new</span> CodeGenBlock()); blocks.top()-&gt;block = block; }
    <span class="keyword">void</span> popBlock() { CodeGenBlock *top = blocks.top(); blocks.pop(); <span class="keyword">delete</span> top; }
};</code></pre>
<p class="note">Listing of codegen.cpp</p>
<pre><code class="cpp"><span class="preprocessor">#include "node.h"</span>
<span class="preprocessor">#include "codegen.h"</span>
<span class="preprocessor">#include "parser.hpp"</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="comment">/* Compile the AST into a module */</span>
<span class="keyword">void</span> CodeGenContext::generateCode(NBlock&amp; root)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Generating code...\n"</span>;

	<span class="comment">/* Create the top level interpreter function to call as entry */</span>
	<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> Type*&gt;</span> argTypes;
	FunctionType *ftype = FunctionType::get(Type::getVoidTy(getGlobalContext()), argTypes, <span class="keyword">false</span>);
	mainFunction = Function::Create(ftype, GlobalValue::InternalLinkage, <span class="string">"main"</span>, module);
	BasicBlock *bblock = BasicBlock::Create(getGlobalContext(), <span class="string">"entry"</span>, mainFunction, <span class="number">0</span>);

	<span class="comment">/* Push a new variable/block context */</span>
	pushBlock(bblock);
	root.codeGen(*<span class="keyword">this</span>); <span class="comment">/* emit bytecode for the toplevel block */</span>
	ReturnInst::Create(getGlobalContext(), bblock);
	popBlock();

	<span class="comment">/* Print the bytecode in a human-readable format
	   to see if our program compiled properly
	 */</span>
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Code is generated.\n"</span>;
	PassManager pm;
	pm.add(createPrintModulePass(&amp;outs()));
	pm.run(*module);
}

<span class="comment">/* Executes the AST by running the main function */</span>
GenericValue CodeGenContext::runCode() {
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Running code...\n"</span>;
	ExistingModuleProvider *mp = <span class="keyword">new</span> ExistingModuleProvider(module);
	ExecutionEngine *ee = ExecutionEngine::create(mp, <span class="keyword">false</span>);
	<span class="stl_container"><span class="built_in">vector</span>&lt;GenericValue&gt;</span> noargs;
	GenericValue v = ee-&gt;runFunction(mainFunction, noargs);
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Code was run.\n"</span>;
	<span class="keyword">return</span> v;
}

<span class="comment">/* Returns an LLVM type based on the identifier */</span>
<span class="keyword">static</span> <span class="keyword">const</span> Type *typeOf(<span class="keyword">const</span> NIdentifier&amp; type)
{
	<span class="keyword">if</span> (type.name.compare(<span class="string">"int"</span>) == <span class="number">0</span>) {
		<span class="keyword">return</span> Type::getInt64Ty(getGlobalContext());
	}
	<span class="keyword">else</span> <span class="keyword">if</span> (type.name.compare(<span class="string">"double"</span>) == <span class="number">0</span>) {
		<span class="keyword">return</span> Type::getDoubleTy(getGlobalContext());
	}
	<span class="keyword">return</span> Type::getVoidTy(getGlobalContext());
}

<span class="comment">/* -- Code Generation -- */</span>

Value* NInteger::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating integer: "</span> &lt;&lt; value &lt;&lt; endl;
	<span class="keyword">return</span> ConstantInt::get(Type::getInt64Ty(getGlobalContext()), value, <span class="keyword">true</span>);
}

Value* NDouble::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating double: "</span> &lt;&lt; value &lt;&lt; endl;
	<span class="keyword">return</span> ConstantFP::get(Type::getDoubleTy(getGlobalContext()), value);
}

Value* NIdentifier::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating identifier reference: "</span> &lt;&lt; name &lt;&lt; endl;
	<span class="keyword">if</span> (context.locals().find(name) == context.locals().end()) {
		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"undeclared variable "</span> &lt;&lt; name &lt;&lt; endl;
		<span class="keyword">return</span> NULL;
	}
	<span class="keyword">return</span> <span class="keyword">new</span> LoadInst(context.locals()[name], <span class="string">""</span>, <span class="keyword">false</span>, context.currentBlock());
}

Value* NMethodCall::codeGen(CodeGenContext&amp; context)
{
	Function *function = context.module-&gt;getFunction(id.name.c_str());
	<span class="keyword">if</span> (function == NULL) {
		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"no such function "</span> &lt;&lt; id.name &lt;&lt; endl;
	}
	<span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;Value*&gt;</span> args;
	ExpressionList::const_iterator it;
	<span class="keyword">for</span> (it = arguments.begin(); it != arguments.end(); it++) {
		args.push_back((**it).codeGen(context));
	}
	CallInst *call = CallInst::Create(function, args.begin(), args.end(), <span class="string">""</span>, context.currentBlock());
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating method call: "</span> &lt;&lt; id.name &lt;&lt; endl;
	<span class="keyword">return</span> call;
}

Value* NBinaryOperator::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating binary operation "</span> &lt;&lt; op &lt;&lt; endl;
	Instruction::BinaryOps instr;
	<span class="keyword">switch</span> (op) {
		<span class="keyword">case</span> TPLUS: 	instr = Instruction::Add; <span class="keyword">goto</span> math;
		<span class="keyword">case</span> TMINUS: 	instr = Instruction::Sub; <span class="keyword">goto</span> math;
		<span class="keyword">case</span> TMUL: 		instr = Instruction::Mul; <span class="keyword">goto</span> math;
		<span class="keyword">case</span> TDIV: 		instr = Instruction::SDiv; <span class="keyword">goto</span> math;

		<span class="comment">/* TODO comparison */</span>
	}

	<span class="keyword">return</span> NULL;
math:
	<span class="keyword">return</span> BinaryOperator::Create(instr, lhs.codeGen(context),
		rhs.codeGen(context), <span class="string">""</span>, context.currentBlock());
}

Value* NAssignment::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating assignment for "</span> &lt;&lt; lhs.name &lt;&lt; endl;
	<span class="keyword">if</span> (context.locals().find(lhs.name) == context.locals().end()) {
		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"undeclared variable "</span> &lt;&lt; lhs.name &lt;&lt; endl;
		<span class="keyword">return</span> NULL;
	}
	<span class="keyword">return</span> <span class="keyword">new</span> StoreInst(rhs.codeGen(context), context.locals()[lhs.name], <span class="keyword">false</span>, context.currentBlock());
}

Value* NBlock::codeGen(CodeGenContext&amp; context)
{
	StatementList::const_iterator it;
	Value *last = NULL;
	<span class="keyword">for</span> (it = statements.begin(); it != statements.end(); it++) {
		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Generating code for "</span> &lt;&lt; <span class="keyword">typeid</span>(**it).name() &lt;&lt; endl;
		last = (**it).codeGen(context);
	}
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating block"</span> &lt;&lt; endl;
	<span class="keyword">return</span> last;
}

Value* NExpressionStatement::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Generating code for "</span> &lt;&lt; <span class="keyword">typeid</span>(expression).name() &lt;&lt; endl;
	<span class="keyword">return</span> expression.codeGen(context);
}

Value* NVariableDeclaration::codeGen(CodeGenContext&amp; context)
{
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating variable declaration "</span> &lt;&lt; type.name &lt;&lt; <span class="string">" "</span> &lt;&lt; id.name &lt;&lt; endl;
	AllocaInst *alloc = <span class="keyword">new</span> AllocaInst(typeOf(type), id.name.c_str(), context.currentBlock());
	context.locals()[id.name] = alloc;
	<span class="keyword">if</span> (assignmentExpr != NULL) {
		NAssignment assn(id, *assignmentExpr);
		assn.codeGen(context);
	}
	<span class="keyword">return</span> alloc;
}

Value* NFunctionDeclaration::codeGen(CodeGenContext&amp; context)
{
	<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> Type*&gt;</span> argTypes;
	VariableList::const_iterator it;
	<span class="keyword">for</span> (it = arguments.begin(); it != arguments.end(); it++) {
		argTypes.push_back(typeOf((**it).type));
	}
	FunctionType *ftype = FunctionType::get(typeOf(type), argTypes, <span class="keyword">false</span>);
	Function *function = Function::Create(ftype, GlobalValue::InternalLinkage, id.name.c_str(), context.module);
	BasicBlock *bblock = BasicBlock::Create(getGlobalContext(), <span class="string">"entry"</span>, function, <span class="number">0</span>);

	context.pushBlock(bblock);

	<span class="keyword">for</span> (it = arguments.begin(); it != arguments.end(); it++) {
		(**it).codeGen(context);
	}

	block.codeGen(context);
	ReturnInst::Create(getGlobalContext(), bblock);

	context.popBlock();
	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating function: "</span> &lt;&lt; id.name &lt;&lt; endl;
	<span class="keyword">return</span> function;
}</code></pre>
<p>There is certainly a great deal to take in here, however this is the 
part where you should start exploring on your own. I only have a couple 
of notes: </p>
<ul>
<li>We use a “stack” of blocks in our CodeGenContext class to keep the 
last entered block (because instructions are added to blocks) </li>
<li>We also use this stack to keep a <a 
href="http://en.wikipedia.org/wiki/Symbol_table">symbol table</a> of the
 local variables in each block. </li>
<li>Our toy program only knows about variables in its own scope. To 
support the idea of “global” contexts you’d need to search upwards 
through each block in our stack until you found a match to the symbol 
(rather than simply searching the top symbol table). </li>
<li>Before entering a block we should push the block and when leaving it
 we should pop it. </li>
</ul>
<p>The rest of the details are all related to LLVM, and again, I’m 
hardly an expert on that subject. But at this point, we have all of the 
code we need to compile our toy language and watch it run.</p>
<p><!--nextpage--><br>
<!--pagetitle:Building and Running Our Toy Language--></p>
<h2>Building Our Toy Language</h2>
<p>We have the code, but how to we build it? LLVM can be complicated to 
link, fortunately if you installed LLVM you also got an <code>llvm-config</code>
 binary which returns all of the compiler/linker flags you need.</p>
<p>We also need to update our main.cpp file from earlier to actually 
compile and run our code, this time:</p>
<p class="note">Listing of main.cpp:</p>
<pre><code class="cpp"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "codegen.h"</span>
<span class="preprocessor">#include "node.h"</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">extern</span> <span class="keyword">int</span> yyparse();
<span class="keyword">extern</span> NBlock* programBlock;

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)
{
    yyparse();
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; programBlock &lt;&lt; endl;

    CodeGenContext context;
    context.generateCode(*programBlock);
    context.runCode();

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
<p>Now all we need to do is compile:</p>
<pre><code class=" ruby"><span class="variable">$ </span><span class="identifier">g</span>++ -<span class="identifier">o</span> <span class="identifier">parser</span> `<span class="identifier">llvm</span>-<span class="identifier">config</span> --<span class="identifier">libs</span> <span class="identifier">core</span> <span class="identifier">jit</span> <span class="identifier">native</span> --<span class="identifier">cxxflags</span> --<span class="identifier">ldflags</span>` *.<span class="identifier">cpp</span></code></pre>
<p>You can also grab this Makefile to make things easier:</p>
<p class="note">Listing of Makefile:</p>
<pre><code class=" ruby"><span class="identifier">all</span><span class="symbol">:</span> <span class="identifier">parser</span>

<span class="identifier">clean</span><span class="symbol">:</span>
	<span class="identifier">rm</span> <span class="identifier">parser</span>.<span class="identifier">cpp</span> <span class="identifier">parser</span>.<span class="identifier">hpp</span> <span class="identifier">parser</span> <span class="identifier">tokens</span>.<span class="identifier">cpp</span>

<span class="identifier">parser</span>.<span class="identifier">cpp</span><span class="symbol">:</span> <span class="identifier">parser</span>.<span class="identifier">y</span>
	<span class="identifier">bison</span> -<span class="identifier">d</span> -<span class="identifier">o</span> <span class="variable">$@</span> <span class="variable">$^</span>

<span class="identifier">parser</span>.<span class="identifier">hpp</span><span class="symbol">:</span> <span class="identifier">parser</span>.<span class="identifier">cpp</span>

<span class="identifier">tokens</span>.<span class="identifier">cpp</span><span class="symbol">:</span> <span class="identifier">tokens</span>.<span class="identifier">l</span> <span class="identifier">parser</span>.<span class="identifier">hpp</span>
	<span class="identifier">lex</span> -<span class="identifier">o</span> <span class="variable">$@</span> <span class="variable">$^</span>

<span class="identifier">parser</span><span class="symbol">:</span> <span class="identifier">parser</span>.<span class="identifier">cpp</span> <span class="identifier">codegen</span>.<span class="identifier">cpp</span> <span class="identifier">main</span>.<span class="identifier">cpp</span> <span class="identifier">tokens</span>.<span class="identifier">cpp</span>
	<span class="identifier">g</span>++ -<span class="identifier">o</span> <span class="variable">$@</span> `<span class="identifier">llvm</span>-<span class="identifier">config</span> --<span class="identifier">libs</span> <span class="identifier">core</span> <span class="identifier">jit</span> <span class="identifier">native</span> --<span class="identifier">cxxflags</span> --<span class="identifier">ldflags</span>` *.<span class="identifier">cpp</span></code></pre>
<h2>Running Our Toy Language</h2>
<p>Hopefully everything compiled properly. At this point you should have
 your parser binary that spits out code. Play with it. Remember our 
canonical example? Let’s see what our program does.</p>
<pre><code class=" javascript">$ echo <span class="string">'int do_math(int a) { int x = a * 5 + 3 } do_math(10)'</span> | ./parser
<span class="number">0x100a00f10</span>
Generating code...
Generating code <span class="keyword">for</span> <span class="number">20</span>NFunctionDeclaration
Creating variable declaration int a
Generating code <span class="keyword">for</span> <span class="number">20</span>NVariableDeclaration
Creating variable declaration int x
Creating assignment <span class="keyword">for</span> x
Creating binary operation <span class="number">276</span>
Creating binary operation <span class="number">274</span>
Creating integer: <span class="number">3</span>
Creating integer: <span class="number">5</span>
Creating identifier reference: a
Creating block
Creating <span class="function"><span class="keyword">function</span>: <span class="title">do_math</span>
<span class="title">Generating</span> <span class="title">code</span> <span class="title">for</span> 20<span class="title">NExpressionStatement</span>
<span class="title">Generating</span> <span class="title">code</span> <span class="title">for</span> 11<span class="title">NMethodCall</span>
<span class="title">Creating</span> <span class="title">integer</span>: 10
<span class="title">Creating</span> <span class="title">method</span> <span class="title">call</span>: <span class="title">do_math</span>
<span class="title">Creating</span> <span class="title">block</span>
<span class="title">Code</span> <span class="title">is</span> <span class="title">generated</span>.
; <span class="title">ModuleID</span> = '<span class="title">main</span>'

<span class="title">define</span> <span class="title">internal</span> <span class="title">void</span> @<span class="title">main</span><span class="params">()</span> {</span>
entry:
	%<span class="number">0</span> = call i64 @do_math(i64 <span class="number">10</span>)		; <i64> [#uses=<span class="number">0</span>]
	ret <span class="keyword">void</span>
}

define internal i64 @do_math(i64) {
entry:
	%a = alloca i64		; <i64 *=""> [#uses=<span class="number">1</span>]
	%x = alloca i64		; <i64 *=""> [#uses=<span class="number">1</span>]
	%<span class="number">1</span> = add i64 <span class="number">5</span>, <span class="number">3</span>	; <i64> [#uses=<span class="number">1</span>]
	%<span class="number">2</span> = load i64* %a	; <i64> [#uses=<span class="number">1</span>]
	%<span class="number">3</span> = mul i64 %<span class="number">2</span>, %<span class="number">1</span>	; <i64> [#uses=<span class="number">1</span>]
	store i64 %<span class="number">3</span>, i64* %x
	ret <span class="keyword">void</span>
}
Running code...
Code was run.</i64></i64></i64></i64></i64></i64></code></pre>
<p><!--nextpage--><br>
<!--pagetitle:Conclusion--></p>
<p>Isn’t that pretty cool? I’ll admit it’s probably less satisfying to 
get something running when you just copy paste from a how to guide, but 
getting this running should still be interesting for you. Plus, and this
 is the best part, this isn’t the end of the guide, it’s just the 
beginning, because this is the part where <em>you</em> start tacking on 
crazy features to this lexer, parser and assembler to create a language 
that you can call your own. You have all the building blocks, and you 
should have a basic idea of how to continue on.</p>
<p>The code, by the way, is available on Github <a 
href="http://github.com/lsegal/my_toy_compiler">here</a>. I avoided 
saying this because the code was not the point of the article, but 
rather going over the code in detail was. If you’re just going to grab 
the code it sort of defeats the purpose of writing your own compiler.</p>
<p>I realize this is a huge article, and there are probably mistakes, so
 if you run into problems, feel free to send me an email and I’ll make 
adjustments. If you want to share some info, feel free to do that as 
well.</p>
<p style="text-align: right;"></p><div class="multipage"><span 
class="contentjumplink">Previous Page</span><ol class="contentlist"><li><a
 class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/">Introduction</a></li><li><a
 class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/2/">Getting
 Started</a></li><li><a class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/3/">Step1.
 Lexical Analysis with Flex</a></li><li><a class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/4/">Step 
2. Semantic Parsing with Bison</a></li><li><a class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/5/">Generating
 Flex and Bison Code</a></li><li><a class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/6/">Step 
3. Assembling the AST with LLVM</a></li><li><a class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/7/">Building
 and Running Our Toy Language</a></li><li><a class="contentlist" 
href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/8/">Conclusion</a></li><li
 class="contentlistall">View All</li></ol><span class="contentjumplink">Next
 Page</span></div>      </div>

              <div class="talktome">Questions? Comments? Follow me on 
Twitter (<a href="http://twitter.com/lsegal">@lsegal</a>) or <a 
href="mailto:lsegal@soen.ca">email me</a>.</div>
          </div>

  


        <div id="copyright">Copyright © 2009 Loren Segal. <small>I can't
 guarantee this works in IE6.</small></div>
      </div>
      <div id="nav">
        <div class="section about">
          <h2>About</h2>
          <p>
          <img alt="Me" 
src="WritingYourCompilerUsingLLVM_arquivos/6460_549798407904_48300380_33486194_6308796_n_bigger.jpg"
 align="right">
          I'm <strong>Loren Segal</strong>, a programmer, Rubyist, 
author of <a href="http://yard.soen.ca/" title="Yay! A Ruby 
Documentation Tool">YARD</a>, musician, photographer and writer from <strong>Montreal,
 Canada</strong> <small>(<a href="http://gnuu.org/about">read more</a> |
 <a href="http://feeds.feedburner.com/connectnothing">rss</a>)</small></p>
        </div>
        
                  <div class="section articles">
            <h2>Other Articles</h2>
            
            <ul>
                          <li><a 
href="http://gnuu.org/2010/03/26/lets-do-some-engineering-pt-1-design-patterns/"
 title="Let’s Do Some Engineering Pt. 1: Design Patterns">Let’s Do Some 
Engineering Pt. 1: Design Patterns </a></li>
                          <li><a 
href="http://gnuu.org/2010/03/25/fixing-rubys-inheritance-model/" 
title="Fixing Ruby’s Inheritance Model with Metamorph">Fixing Ruby’s 
Inheritance Model with Metamorph </a></li>
                          <li><a 
href="http://gnuu.org/2010/03/24/documentation-and-the-whole-nine-yards-mwrc-2010/"
 title="Documentation and the Whole Nine YARDs (MWRC 2010)">Documentation
 and the Whole Nine YARDs (MWRC 2010) </a></li>
                          <li><a 
href="http://gnuu.org/2009/12/18/visualizing-class-relationships/" 
title="Visualizing Class Relationships with YARD and InfoVis">Visualizing
 Class Relationships with YARD and InfoVis </a></li>
                          <li><a href="http://gnuu.org/page/1">More...</a></li>
            </ul>
                      </div>
                
        <div class="section twitter">
          <h2>
            <span class="title">Twitter Feed</span> <a class="follow" 
href="http://twitter.com/lsegal">follow me</a>
            <span style="color: rgb(17, 17, 17); clear: both;">.</span>
          </h2>
          
          <div class="twitterapp"><ul class="twitterapplist"><li>Oh they
 threw in an orientation lock on the iPad. That's smart. I hate how the 
iPhone always randomly switches to landscape. <small>50m ago | <a 
href="http://twitter.com/lsegal/status/11265290156">link</a></small></li><li>iPad:
 the $500 digital photo frame. <small>53m ago | <a 
href="http://twitter.com/lsegal/status/11265171788">link</a></small></li><li>But
 I guess it's all just image data... <small>11h ago | <a 
href="http://twitter.com/lsegal/status/11239693705">link</a></small></li><li>HTML5
 Canvas stuff would be way better if you could interact with shapes via 
DOM, or better yet, apply CSS with selectors. <small>11h ago | <a 
href="http://twitter.com/lsegal/status/11239682010">link</a></small></li><li>Wut?
 http://imgur.com/3l1JP.png ..totally works if I type it in manually. <small>14h
 ago | <a href="http://twitter.com/lsegal/status/11234702070">link</a></small></li><li>The
 more I think about it, the more I should replace my dual monitors with a
 single 24" <small>14h ago | <a 
href="http://twitter.com/lsegal/status/11234267690">link</a></small></li></ul></div>
        </div>

                <div class="section ads">
          <script type="text/javascript"><!--
google_ad_client = "pub-2497446755186719";
/* 180x150, created 3/27/10 */
google_ad_slot = "5914781461";
google_ad_width = 180;
google_ad_height = 150;
//-->
</script>
<script type="text/javascript" src="WritingYourCompilerUsingLLVM_arquivos/show_ads.js">
</script><script src="WritingYourCompilerUsingLLVM_arquivos/expansion_embed.js"></script><script src="WritingYourCompilerUsingLLVM_arquivos/test_domain.js"></script><script>google_protectAndRun("ads_core.google_render_ad", google_handleError, google_render_ad);</script><ins
 style="display: inline-table; border: medium none; height: 150px; 
margin: 0pt; padding: 0pt; position: relative; visibility: visible; 
width: 180px;"><ins style="display: block; border: medium none; height: 
150px; margin: 0pt; padding: 0pt; position: relative; visibility: 
visible; width: 180px;"><iframe allowtransparency="true" hspace="0" 
id="google_ads_frame1" marginheight="0" marginwidth="0" 
name="google_ads_frame" 
src="WritingYourCompilerUsingLLVM_arquivos/ads.htm" style="left: 0pt; 
position: absolute; top: 0pt;" vspace="0" scrolling="no" frameborder="0"
 height="150" width="180"></iframe></ins></ins>
        </div>
              </div>
      <br style="clear: both;">
    </div>
    
    
    <!-- clicky -->
		<script type="text/javascript">
var domainy = location.protocol == "https:" ? "https://static.getclicky.com" : "http://static.getclicky.com";
document.write(unescape("%3Cscript src='" + domainy + "/134242.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="WritingYourCompilerUsingLLVM_arquivos/134242.js" type="text/javascript"></script>
<noscript><p><img alt="Clicky" width="1" height="1" src="http://static.getclicky.com/134242-db17.gif" /></p></noscript>




    <!-- google analytics -->
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script src="WritingYourCompilerUsingLLVM_arquivos/ga.js" type="text/javascript"></script>
    <script type="text/javascript">
        try {
            var pageTracker = _gat._getTracker("UA-7172246-1");
            pageTracker._trackPageview();
        } catch(err) {}
    </script>
  <!-- Dynamic page generated in 0.213 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2010-03-29 14:59:38 -->
<!-- super cache --></body></html>